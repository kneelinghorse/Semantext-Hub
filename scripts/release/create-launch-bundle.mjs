#!/usr/bin/env node

import fs from 'node:fs/promises';
import { constants as fsConstants } from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

import { createConsole } from '../../src/cli/ux/console.js';
import { runExternalPipeline, DEFAULT_VERSION, PROVIDERS } from '../demo/run-external.mjs';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

function parseArgs(argv) {
  const options = {
    workspace: process.cwd(),
    version: DEFAULT_VERSION,
    overwrite: false,
    dryRun: false,
    help: false
  };

  for (let index = 0; index < argv.length; index += 1) {
    const arg = argv[index];
    switch (arg) {
      case '--workspace':
      case '-w':
        options.workspace = path.resolve(argv[++index]);
        break;
      case '--version':
      case '-v':
        options.version = argv[++index];
        break;
      case '--overwrite':
        options.overwrite = true;
        break;
      case '--dry-run':
        options.dryRun = true;
        break;
      case '--help':
      case '-h':
        options.help = true;
        break;
      default:
        throw new Error(`Unknown option: ${arg}`);
    }
  }

  return options;
}

function printHelp() {
  console.log(`Semantext Hub Launch Bundle Builder\n\nUsage: node scripts/release/create-launch-bundle.mjs [options]\n\nOptions:\n  -w, --workspace <path>  Workspace root (defaults to current directory)\n  -v, --version <tag>      Launch bundle version (defaults to ${DEFAULT_VERSION})\n      --overwrite          Overwrite existing bundle contents\n      --dry-run            Report planned actions without writing files\n  -h, --help               Show this help message\n`);
}

async function ensureDirectory(targetDir) {
  await fs.mkdir(targetDir, { recursive: true });
}

async function copyArtifact(source, target, { overwrite, dryRun, consoleUi }) {
  if (dryRun) {
    consoleUi.info(`dry-run: ${source} -> ${target}`);
    return false;
  }

  await ensureDirectory(path.dirname(target));

  const cloneFlag = fsConstants.COPYFILE_FICLONE_FORCE ?? 0;
  const exclusiveFlag = fsConstants.COPYFILE_EXCL ?? 0;

  try {
    if (overwrite) {
      try {
        await fs.copyFile(source, target, cloneFlag);
      } catch (error) {
        if (error.code === 'ENOSYS' || error.code === 'ERR_FS_COPYFILE_IMPLIES_OTHER' || cloneFlag === 0) {
          await fs.copyFile(source, target);
        } else {
          throw error;
        }
      }
    } else {
      await fs.copyFile(source, target, exclusiveFlag);
    }
  } catch (error) {
    if (!overwrite && error.code === 'EEXIST') {
      consoleUi.warn(`Preserving existing artifact: ${target}`);
      return false;
    }

    throw error;
  }

  return true;
}

function generateReadme(version, providers) {
  const providerLines = providers
    .map(
      (provider) =>
        `- **${provider.name}** (${provider.id}) — manifest \`${provider.manifest}\`, diagram \`${provider.diagram}\`, telemetry \`${provider.telemetry}\``
    )
    .join('\n');

  return `# Semantext Hub Launch Bundle — ${version}\n\nThis directory is generated by \`node scripts/release/create-launch-bundle.mjs\`. It packages the curated external showcase used for the v0.25 release.\n\n## Contents\n\n${providerLines}\n- **Scripts** — \`scripts/run-external.mjs\` regenerates provider artifacts.\n- **Notes** — \`notes/external-showcase.md\` documents the GitHub/Stripe walkthrough.\n\n## Regenerate\n\n\`\`\`bash\nnpm run demo:preflight\nnode scripts/release/create-launch-bundle.mjs --overwrite\n\`\`\`\n\nRun with \`--dry-run\` to preview changes or \`--version <tag>\` to stage future releases.\n`;
}

async function writeTextFile(targetPath, contents, { overwrite, dryRun, consoleUi }) {
  if (dryRun) {
    consoleUi.info(`dry-run: write ${targetPath}`);
    return false;
  }

  if (!overwrite) {
    try {
      await fs.stat(targetPath);
      consoleUi.warn(`Preserving existing text file: ${targetPath}`);
      return false;
    } catch (error) {
      if (error.code !== 'ENOENT') {
        throw error;
      }
    }
  }

  await ensureDirectory(path.dirname(targetPath));
  await fs.writeFile(targetPath, contents, 'utf8');
  return true;
}

async function main() {
  const consoleUi = createConsole();
  const args = parseArgs(process.argv.slice(2));

  if (args.help) {
    printHelp();
    return;
  }

  const { launchDir, results } = await runExternalPipeline({
    workspace: args.workspace,
    version: args.version,
    overwrite: args.overwrite,
    dryRun: args.dryRun
  });

  const providers = results.map((entry) => {
    const config = PROVIDERS[entry.provider];
    const manifest = path.relative(launchDir, entry.targets.manifest);
    const diagram = path.relative(launchDir, entry.targets.diagram);
    const telemetry = path.relative(launchDir, entry.targets.telemetry);

    return {
      id: entry.provider,
      name: entry.name,
      manifest,
      diagram,
      telemetry,
      spec: config?.spec ?? null
    };
  });

  const scriptSource = path.resolve(args.workspace, 'scripts', 'demo', 'run-external.mjs');
  const scriptTarget = path.join(launchDir, 'scripts', 'run-external.mjs');

  const showcaseSource = path.resolve(args.workspace, 'docs', 'demos', 'external-showcase.md');
  const showcaseTarget = path.join(launchDir, 'notes', 'external-showcase.md');

  const metadataTarget = path.join(launchDir, 'metadata.json');
  const readmeTarget = path.join(launchDir, 'README.md');
  const metadata = {
    version: args.version,
    generated_at: new Date().toISOString(),
    providers
  };

  if (args.dryRun) {
    consoleUi.info('Launch bundle dry-run complete');
    return;
  }

  const copiedScript = await copyArtifact(scriptSource, scriptTarget, {
    overwrite: args.overwrite,
    dryRun: args.dryRun,
    consoleUi
  });

  await copyArtifact(showcaseSource, showcaseTarget, {
    overwrite: args.overwrite,
    dryRun: args.dryRun,
    consoleUi
  });

  await writeTextFile(metadataTarget, `${JSON.stringify(metadata, null, 2)}\n`, {
    overwrite: true,
    dryRun: args.dryRun,
    consoleUi
  });

  await writeTextFile(readmeTarget, generateReadme(args.version, providers), {
    overwrite: args.overwrite,
    dryRun: args.dryRun,
    consoleUi
  });

  consoleUi.success('Launch bundle ready', [
    launchDir,
    copiedScript ? 'scripts/run-external.mjs refreshed' : 'scripts/run-external.mjs preserved',
    `${providers.length} provider entries recorded`
  ]);
}

main().catch((error) => {
  const consoleUi = createConsole();
  consoleUi.error('Launch bundle build failed', [error.message ?? String(error)]);
  process.exitCode = 1;
});
